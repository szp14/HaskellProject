
==================== FINAL INTERFACE ====================
2017-01-14 09:36:08.881969 UTC

interface Compiler-0.1.0.0-57coiQcmnJXARK4xYqZ5Rd:Argument 8001
  interface hash: a2bfdc5c0cb3e172d5ed1b39eecf7941
  ABI hash: 06162cb401ea715e9611b3a146682803
  export-list hash: a8ca271755ee91e85a58205e26c93000
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a4046e0fdab24403354cf30558c1ea1c
  sig of: Nothing
  used TH splices: False
  where
exports:
  Argument.defMain
  Argument.parseField
  Argument.parseFlag
  Argument.parseInPath
  Argument.parseOption
  Argument.parseOutPath
  Argument.parseRepl
  Argument.parseTreePath
  Argument.Option{Argument.Option funType inPath outPath}
  Argument.Parser
module dependencies: Grammar Interpreter PrettyPrinter Repl
package dependencies: array-0.5.1.1@array-0.5.1.1
                      attoparsec-0.13.1.0@attoparsec-0.13.1.0-4RIYnAHyOmg6Dh17ENWi43
                      base-4.9.0.0 binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      hashable-1.2.4.0@hashable-1.2.4.0-Ctl752zbguF6QanxurLOm2
                      integer-gmp-1.0.0.1
                      integer-logarithms-1@integer-logarithms-1-E6LvTbkhTkGIa6wPB3rtJw
                      mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM
                      pretty-1.1.3.3@pretty-1.1.3.3
                      primitive-0.6.1.0@primitive-0.6.1.0-Ip44DqhfCp21tTUYbecwa
                      scientific-0.3.4.10@scientific-0.3.4.10-2Y658Wts4fDGgAkWhKOJwC
                      text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs
                      transformers-0.5.2.0@transformers-0.5.2.0
                      vector-0.11.0.0@vector-0.11.0.0-6uB77qGCxR6GPLxI2sqsX3
orphans: Compiler-0.1.0.0-57coiQcmnJXARK4xYqZ5Rd:PrettyPrinter
         attoparsec-0.13.1.0@attoparsec-0.13.1.0-4RIYnAHyOmg6Dh17ENWi43:Data.Attoparsec.Text.Internal
         base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.4.0@hashable-1.2.4.0-Ctl752zbguF6QanxurLOm2:Data.Hashable.Generic
         text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs:Data.Text
         text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs:Data.Text.Show
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         vector-0.11.0.0@vector-0.11.0.0-6uB77qGCxR6GPLxI2sqsX3:Data.Vector.Fusion.Bundle
family instance modules: attoparsec-0.13.1.0@attoparsec-0.13.1.0-4RIYnAHyOmg6Dh17ENWi43:Data.Attoparsec.Internal.Types
                         base-4.9.0.0:Control.Applicative base-4.9.0.0:Data.Complex
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Functor.Identity base-4.9.0.0:Data.List.NonEmpty
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Semigroup
                         base-4.9.0.0:Data.Type.Equality base-4.9.0.0:Data.Version
                         base-4.9.0.0:Data.Void base-4.9.0.0:GHC.Exts
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primitive-0.6.1.0-Ip44DqhfCp21tTUYbecwa:Control.Monad.Primitive
                         text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs:Data.Text
                         text-1.2.2.1@text-1.2.2.1-9Yh8rJoh8fO2JMLWffT3Qs:Data.Text.Lazy
                         vector-0.11.0.0@vector-0.11.0.0-6uB77qGCxR6GPLxI2sqsX3:Data.Vector
import  -/  Grammar 0e49269890a957871754979fc1cf94a7
  exports: 5a094fe8ecb7bd19ccbd179c56554a95
import  -/  Interpreter 2017a2b0cf73cf6a36a89828d70c41dd
  exports: 23cb7ab98af56ee8dae95c05c887ae4f
  interpreter 0f25d898f977cdb4c9047952ebb66963
import  -/  PrettyPrinter 94b7a10b3d2e718739a283ef4638dfa3
  exports: 41d74f5a644d71dea58e42c2f5691932
  prettyPrinter fa2be77e3c83dc1b70ff820779752155
import  -/  Repl db4477fad43cc0d3a937226ffa3b4054
  exports: 7cbebf98c4270ff2930d7eeb1bd7c3a2
  repl d3add995dd33061a588c2d71775e1308
import  -/  base-4.9.0.0:Control.Applicative 7728b33d6969dce59e89474349eb1397
import  -/  base-4.9.0.0:Data.Either bd9f099b82d4ed2d98c56d7144ac6957
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.IO.Handle a1938753d58593f0a419f85b67aa7cd3
import  -/  base-4.9.0.0:GHC.IO.Handle.FD 13b7a4e1f414dd38346bde554423bf4b
import  -/  base-4.9.0.0:GHC.IO.Handle.Text 23b6dc4ed000f42bf105ce56bdeb0dc6
import  -/  base-4.9.0.0:GHC.IO.IOMode 9380a6a6b8c50facc225c4877c5e1e90
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:System.Environment ee0914a962f5508d0fd404c89ee4999b
import  -/  base-4.9.0.0:System.IO ad985d7a3fc986e9b9c610fb344d9106
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 8f3eaf1368a7ea27857993e3febae6a3
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base 8d095ad71634b5551ba5dc1307b7f9e5
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State d851912d62cbc95e043a9cc13c3581de
import  -/  mtl-2.2.1@mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM:Control.Monad.State.Class bb09f604e4f3565edc4a2b432f1b5445
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 16a585e7f12cd771300b3cab638df233
d80fb82c2b95bdf0ac4d3d459dd23f0a
  $fShowOption :: GHC.Show.Show Argument.Option
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Argument.Option
                  Argument.$fShowOption_$cshowsPrec
                  Argument.$fShowOption_$cshow
                  Argument.$fShowOption_$cshowList -}
d80fb82c2b95bdf0ac4d3d459dd23f0a
  $fShowOption1 :: Argument.Option -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Argument.Option) (w1 :: GHC.Base.String) ->
                 case w of ww { Argument.Option ww1 ww2 ww3 ->
                 Argument.$w$cshowsPrec 0# ww1 ww2 ww3 w1 }) -}
55f544d1b3872f920189521ef6bc6791
  $fShowOption2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
6c93f5380c6f1ef2f1d8a0914d0279fe
  $fShowOption3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "funType = "#) -}
969d464b14e783cf9455db94a0fa62d6
  $fShowOption4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "outPath = "#) -}
40d6e686fd30319348600500c1214721
  $fShowOption5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
815cfe45f8406551081be39871116511
  $fShowOption6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "inPath = "#) -}
d61f36aab0104521a28faf447085fd90
  $fShowOption7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Option {"#) -}
d80fb82c2b95bdf0ac4d3d459dd23f0a
  $fShowOption_$cshow :: Argument.Option -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Argument.Option) ->
                 Argument.$fShowOption_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
d80fb82c2b95bdf0ac4d3d459dd23f0a
  $fShowOption_$cshowList :: [Argument.Option] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Argument.Option
                   Argument.$fShowOption1) -}
d80fb82c2b95bdf0ac4d3d459dd23f0a
  $fShowOption_$cshowsPrec ::
    GHC.Types.Int -> Argument.Option -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U,1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Argument.Option)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Argument.Option ww3 ww4 ww5 ->
                 Argument.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
1414bee35b6cec3bbaa498e80f1f0922
  $tc'Option :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6920996451730248499##
                   8858590699114234307##
                   Argument.$trModule
                   Argument.$tc'Option1) -}
9f26ebabe77a88106aeee55908d42b5c
  $tc'Option1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Option"#) -}
b19c5c41b7740149a0b8d7faef8783d6
  $tcOption :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13890528202543010301##
                   9470339201156351923##
                   Argument.$trModule
                   Argument.$tcOption1) -}
94f1a5c2900fed7d6ef30983f407064c
  $tcOption1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Option"#) -}
2a1fc645cf3567d5ad700b2770c9161a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Argument.$trModule2
                   Argument.$trModule1) -}
bd62bee80db63d56d0ba4c586db74003
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Argument"#) -}
7c817f71c195d6f53909dcea48010e01
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Compiler-0.1.0.0-57coiQcmnJXARK4xYqZ5Rd"#) -}
07ab02b553c4378ddb22bd592b4fa4ea
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <S,U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Argument.$fShowOption7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Argument.$fShowOption6
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows8
                             (GHC.Show.showLitString
                                ww1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows8
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      Argument.$fShowOption5
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Argument.$fShowOption4
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            (GHC.Show.showLitString
                                               ww2
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.shows8
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Argument.$fShowOption5
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        Argument.$fShowOption3
                                                        (case ww3 of ww4 { GHC.Types.I# ww5 ->
                                                         case GHC.Show.$wshowSignedInt
                                                                0#
                                                                ww5
                                                                (GHC.Base.++
                                                                   @ GHC.Types.Char
                                                                   Argument.$fShowOption2
                                                                   x) of ww6 { (#,#) ww7 ww8 ->
                                                         GHC.Types.:
                                                           @ GHC.Types.Char
                                                           ww7
                                                           ww8 } }))))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w)) }) -}
d80fb82c2b95bdf0ac4d3d459dd23f0a
  data Option
    = Option {inPath :: GHC.Base.String,
              outPath :: GHC.Base.String,
              funType :: GHC.Types.Int}
acd41efc30c459402f6bfe82ca617cde
  type Parser a =
    Control.Monad.Trans.State.Lazy.StateT
      [GHC.Base.String] GHC.Types.IO a
27333084f7e5b10c0a88f97849dc6d11
  defMain :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.defMain1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
0af6bb60ea9b8ed8be5f365109bd698f
  defMain1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U> -}
fbcb882718792311f8146821403f87eb
  funType :: Argument.Option -> GHC.Types.Int
  RecSel Left Argument.Option
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Argument.Option) ->
                 case ds of wild { Argument.Option ds1 ds2 ds3 -> ds3 }) -}
e371f889b12a64c0b4be6001afc65fa3
  inPath :: Argument.Option -> GHC.Base.String
  RecSel Left Argument.Option
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Argument.Option) ->
                 case ds of wild { Argument.Option ds1 ds2 ds3 -> ds1 }) -}
47de2764b2e34530d8a36b9522b06717
  outPath :: Argument.Option -> GHC.Base.String
  RecSel Left Argument.Option
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Argument.Option) ->
                 case ds of wild { Argument.Option ds1 ds2 ds3 -> ds2 }) -}
cc980bd586024a3bec18aeaea2d25041
  parseField :: GHC.Base.String -> Argument.Parser GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (f :: GHC.Base.String) ->
                 let {
                   k :: Control.Monad.Trans.State.Lazy.StateT
                          [GHC.Base.String] GHC.Types.IO GHC.Base.String
                   = case GHC.Base.eqString f Argument.parseField5 of wild {
                       GHC.Types.False
                       -> Argument.parseField4
                            `cast`
                          (Trans
                               (<[GHC.Base.String]>_R
                                ->_R Sym (GHC.Types.N:IO[0]
                                              <(GHC.Base.String, [GHC.Base.String])>_R))
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <[GHC.Base.String]>_N
                                         <GHC.Types.IO>_R
                                         <GHC.Base.String>_N)))
                       GHC.Types.True
                       -> Argument.parseField3
                            `cast`
                          (Trans
                               (<[GHC.Base.String]>_R
                                ->_R Sym (GHC.Types.N:IO[0]
                                              <([GHC.Types.Char], [GHC.Base.String])>_R))
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <[GHC.Base.String]>_N
                                         <GHC.Types.IO>_R
                                         <[GHC.Types.Char]>_N))) }
                 } in
                 let {
                   lvl4 :: [GHC.Types.Char] = GHC.CString.unpackAppendCString# "-"# f
                 } in
                 (\ (s1 :: [GHC.Base.String])
                    (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case s1 of wild {
                    []
                    -> GHC.Prim.raiseIO#
                         @ GHC.Exception.SomeException
                         @ (GHC.Base.String, [GHC.Base.String])
                         Argument.parseField1
                         s
                    : arg args'
                    -> case GHC.Base.eqString arg lvl4 of wild1 {
                         GHC.Types.False
                         -> GHC.Prim.raiseIO#
                              @ GHC.Exception.SomeException
                              @ (GHC.Base.String, [GHC.Base.String])
                              Argument.parseField1
                              s
                         GHC.Types.True
                         -> (k `cast`
                             (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)
                               args')
                              `cast`
                            (GHC.Types.N:IO[0] <(GHC.Base.String, [GHC.Base.String])>_R)
                              s } })
                   `cast`
                 (Trans
                      (<[GHC.Base.String]>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(GHC.Base.String, [GHC.Base.String])>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))) -}
96a1f77aca177bcb0b5becb9abb84e75
  parseField1 :: GHC.Exception.SomeException
  {- Unfolding: (GHC.IO.Exception.$fExceptionIOException_$ctoException
                   Argument.parseField2) -}
481e0fa92282e77bcd1951b573f7e141
  parseField2 :: GHC.IO.Exception.IOException
  {- Unfolding: (GHC.IO.Exception.IOError
                   (GHC.Base.Nothing @ GHC.IO.Handle.Types.Handle)
                   GHC.IO.Exception.UserError
                   (GHC.Types.[] @ GHC.Types.Char)
                   GHC.Base.$fAlternativeIO3
                   (GHC.Base.Nothing @ Foreign.C.Types.CInt)
                   (GHC.Base.Nothing @ GHC.IO.FilePath)) -}
73331b45a3ff04066de21f8980fe76e0
  parseField3 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          ([GHC.Types.Char], [GHC.Base.String]) #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s, (GHC.Types.[] @ GHC.Types.Char, eta1) #)) -}
d524c07759adad25d554224a82000a54
  parseField4 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (s1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case s1 of wild {
                   []
                   -> GHC.IO.failIO1
                        @ (GHC.Base.String, [GHC.Base.String])
                        GHC.Base.$fAlternativeIO3
                        s
                   : arg args' -> (# s, (arg, args') #) }) -}
d68f8494d19c258d4a4cc536580c7f44
  parseField5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "repl"#) -}
2656e724ca3a0df24968403787944aea
  parseFlag :: GHC.Base.String -> Argument.Parser GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseFlag1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R Trans
                          (<[GHC.Base.String]>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <(GHC.Base.String, [GHC.Base.String])>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N))) -}
954e50d0c9db8e7a669dd901285d984d
  parseFlag1 ::
    GHC.Base.String
    -> [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 3, Strictness: <L,U><S,1*U><S,U>,
     Unfolding: (\ (f :: GHC.Base.String)
                   (eta :: [GHC.Base.String])
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case eta of wild {
                   []
                   -> GHC.IO.failIO1
                        @ (GHC.Base.String, [GHC.Base.String])
                        GHC.Base.$fAlternativeIO3
                        eta1
                   : arg args'
                   -> case GHC.Base.eqString
                             arg
                             (GHC.CString.unpackAppendCString# "-"# f) of wild1 {
                        GHC.Types.False
                        -> GHC.IO.failIO1
                             @ (GHC.Base.String, [GHC.Base.String])
                             GHC.Base.$fAlternativeIO3
                             eta1
                        GHC.Types.True -> (# eta1, (f, args') #) } }) -}
f35bb34311c013b6a917fe9eb3b550fe
  parseInPath :: Argument.Parser GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseInPath1
                  `cast`
                (Trans
                     (<[GHC.Base.String]>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <(GHC.Base.String, [GHC.Base.String])>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N))) -}
f397a48df6d6a4eb2357cd6689f6b766
  parseInPath1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case s1 of wild {
                   []
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ (GHC.Base.String, [GHC.Base.String])
                        Argument.parseField1
                        s
                   : arg args'
                   -> case GHC.Base.eqString arg Argument.parseInPath2 of wild1 {
                        GHC.Types.False
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.String, [GHC.Base.String])
                             Argument.parseField1
                             s
                        GHC.Types.True
                        -> (Argument.parseInPath_k
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)
                              args')
                             `cast`
                           (GHC.Types.N:IO[0] <(GHC.Base.String, [GHC.Base.String])>_R)
                             s } }) -}
52fff67606c10eb6bfbc24b911e152ae
  parseInPath2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "-"#
                   Argument.parseInPath_f) -}
a68740707201efea91e2efccf3f770bf
  parseInPath_f :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "i"#) -}
f50e26dfdfb6f67c9f63dd1205fd6a50
  parseInPath_k ::
    Control.Monad.Trans.State.Lazy.StateT
      [GHC.Base.String] GHC.Types.IO GHC.Base.String
  {- Unfolding: (case GHC.Base.eqString
                        Argument.parseInPath_f
                        Argument.parseField5 of wild {
                   GHC.Types.False
                   -> Argument.parseField4
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(GHC.Base.String, [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))
                   GHC.Types.True
                   -> Argument.parseField3
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <([GHC.Types.Char], [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N
                                     <GHC.Types.IO>_R
                                     <[GHC.Types.Char]>_N))) }) -}
6b76f00c22a3b0120925d0fb9672a1b6
  parseOption :: Argument.Parser Argument.Option
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseOption1
                  `cast`
                (Trans
                     (<[GHC.Base.String]>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <(Argument.Option, [GHC.Base.String])>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Base.String]>_N <GHC.Types.IO>_R <Argument.Option>_N))) -}
6821a495da5c03299e24e8039dcd2797
  parseOption1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (Argument.Option, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,U><S,U> -}
f28f8b3392d23aaa6570e28a51801d3b
  parseOutPath :: Argument.Parser GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseOutPath1
                  `cast`
                (Trans
                     (<[GHC.Base.String]>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <(GHC.Base.String, [GHC.Base.String])>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N))) -}
abb8e171c85c507e025edf5010ff6a08
  parseOutPath1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case s1 of wild {
                   []
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ (GHC.Base.String, [GHC.Base.String])
                        Argument.parseField1
                        s
                   : arg args'
                   -> case GHC.Base.eqString arg Argument.parseOutPath2 of wild1 {
                        GHC.Types.False
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.String, [GHC.Base.String])
                             Argument.parseField1
                             s
                        GHC.Types.True
                        -> (Argument.parseOutPath_k
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)
                              args')
                             `cast`
                           (GHC.Types.N:IO[0] <(GHC.Base.String, [GHC.Base.String])>_R)
                             s } }) -}
f2375ec7e8e8cb9bc990cd545635226b
  parseOutPath2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "-"#
                   Argument.parseOutPath_f) -}
9eb05970a814e6ac2e117c5627c2dbb7
  parseOutPath_f :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "o"#) -}
2a14b376363b23699ca60d8b8033cd36
  parseOutPath_k ::
    Control.Monad.Trans.State.Lazy.StateT
      [GHC.Base.String] GHC.Types.IO GHC.Base.String
  {- Unfolding: (case GHC.Base.eqString
                        Argument.parseOutPath_f
                        Argument.parseField5 of wild {
                   GHC.Types.False
                   -> Argument.parseField4
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(GHC.Base.String, [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))
                   GHC.Types.True
                   -> Argument.parseField3
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <([GHC.Types.Char], [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N
                                     <GHC.Types.IO>_R
                                     <[GHC.Types.Char]>_N))) }) -}
d66ac382293fe70ad88ab926d4a173b1
  parseRepl :: Argument.Parser GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseRepl1
                  `cast`
                (Trans
                     (<[GHC.Base.String]>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <(GHC.Base.String, [GHC.Base.String])>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N))) -}
831ef78a9beb3aa9b2392754debeca5c
  parseRepl1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case s1 of wild {
                   []
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ (GHC.Base.String, [GHC.Base.String])
                        Argument.parseField1
                        s
                   : arg args'
                   -> case GHC.Base.eqString arg Argument.parseRepl2 of wild1 {
                        GHC.Types.False
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.String, [GHC.Base.String])
                             Argument.parseField1
                             s
                        GHC.Types.True
                        -> (Argument.parseRepl_k
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)
                              args')
                             `cast`
                           (GHC.Types.N:IO[0] <(GHC.Base.String, [GHC.Base.String])>_R)
                             s } }) -}
01d55b7c1659815a0a2835a409448d02
  parseRepl2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "-"#
                   Argument.parseField5) -}
c908e028f5c99429b3acb8935c52399e
  parseRepl_k ::
    Control.Monad.Trans.State.Lazy.StateT
      [GHC.Base.String] GHC.Types.IO GHC.Base.String
  {- Unfolding: (case GHC.Base.eqString
                        Argument.parseField5
                        Argument.parseField5 of wild {
                   GHC.Types.False
                   -> Argument.parseField4
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(GHC.Base.String, [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))
                   GHC.Types.True
                   -> Argument.parseField3
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <([GHC.Types.Char], [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N
                                     <GHC.Types.IO>_R
                                     <[GHC.Types.Char]>_N))) }) -}
8d0ac6c0bf79c6981db3c40ffe79218a
  parseTreePath :: Argument.Parser GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Argument.parseTreePath1
                  `cast`
                (Trans
                     (<[GHC.Base.String]>_R
                      ->_R Sym (GHC.Types.N:IO[0]
                                    <(GHC.Base.String, [GHC.Base.String])>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N))) -}
c41a5591551ad8b67ed7ce406638c429
  parseTreePath1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          (GHC.Base.String, [GHC.Base.String]) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (s1 :: [GHC.Base.String])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case s1 of wild {
                   []
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.SomeException
                        @ (GHC.Base.String, [GHC.Base.String])
                        Argument.parseField1
                        s
                   : arg args'
                   -> case GHC.Base.eqString arg Argument.parseTreePath2 of wild1 {
                        GHC.Types.False
                        -> GHC.Prim.raiseIO#
                             @ GHC.Exception.SomeException
                             @ (GHC.Base.String, [GHC.Base.String])
                             Argument.parseField1
                             s
                        GHC.Types.True
                        -> (Argument.parseTreePath_k
                              `cast`
                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                 <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)
                              args')
                             `cast`
                           (GHC.Types.N:IO[0] <(GHC.Base.String, [GHC.Base.String])>_R)
                             s } }) -}
527efba932e253ac61513bfb3275d466
  parseTreePath2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   "-"#
                   Argument.parseTreePath_f) -}
c4d744a539777129dadbe538d2f360a7
  parseTreePath_f :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "t"#) -}
bd0895dcd043b59e4fbdb56996ee8c3d
  parseTreePath_k ::
    Control.Monad.Trans.State.Lazy.StateT
      [GHC.Base.String] GHC.Types.IO GHC.Base.String
  {- Unfolding: (case GHC.Base.eqString
                        Argument.parseTreePath_f
                        Argument.parseField5 of wild {
                   GHC.Types.False
                   -> Argument.parseField4
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(GHC.Base.String, [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N <GHC.Types.IO>_R <GHC.Base.String>_N)))
                   GHC.Types.True
                   -> Argument.parseField3
                        `cast`
                      (Trans
                           (<[GHC.Base.String]>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <([GHC.Types.Char], [GHC.Base.String])>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <[GHC.Base.String]>_N
                                     <GHC.Types.IO>_R
                                     <[GHC.Types.Char]>_N))) }) -}
instance GHC.Show.Show [Argument.Option] = Argument.$fShowOption
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

